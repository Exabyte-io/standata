{
    "name": "Valence Band Offset (Polar)",
    "subworkflows": [
        {
            "isMultiMaterial": true,
            "_id": "9c65d03e-6a30-58f3-947a-f174342be0c3",
            "name": "BS + Avg ESP (Interface)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "0",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "0f21d8c4-ab32-53ba-b40d-fc9b6608e1b9",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-right"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "next": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set ESP Profile to Global Scope",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "438d67a5-7f5f-5e02-93ee-a72cb282af06",
            "name": "BS + Avg ESP (Interface Left)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface Left)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "1",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "517eb13b-3632-502b-a32b-8c1e07746827",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-left"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM_LEFT",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential-left"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "next": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set ESP Profile to Global Scope",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "8d784c4d-93f6-5ff4-9cbc-c166c8709e93",
            "name": "Extract Left Coordinates",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Set Material Index",
                    "type": "assignment",
                    "operand": "material_index",
                    "value": "1",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "2d360607-c739-54ad-97a0-8a83f0971f2c",
                    "tags": [],
                    "head": true,
                    "next": "python-extract-coords-left",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "Extract Z-Coordinates from Material",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-extract-coords-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "extract_slab_coordinates.py",
                                "templateName": "extract_slab_coordinates.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "requirements_with_made.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "generic:processing:extract_slab_coordinates",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nExtract z-coordinate boundaries from materials for polar VBO calculation.\n\nReads material data from the job JSON file in the working directory.\nThis is more reliable than reading from pw_scf.out which may be overwritten\nin multi-material workflows.\n\"\"\"\nimport json\nimport os\nimport glob\n\nimport numpy as np\n\n# Material index: 0=Interface, 1=Left, 2=Right\n{% raw %}material_index = int({{material_index}}){% endraw %}\n\n# Find the job JSON file in the current directory\n# It's typically named with the job slug (e.g., \"abc123def.json\")\njson_files = glob.glob(\"*.json\")\njob_file = None\nfor f in json_files:\n    # Skip result files and other known non-job files\n    if f.startswith(\"result\") or f.startswith(\"properties\"):\n        continue\n    # The job file typically has a slug-like name (alphanumeric)\n    basename = os.path.splitext(f)[0]\n    if basename.isalnum() and len(basename) > 10:\n        job_file = f\n        break\n\nif job_file is None:\n    raise FileNotFoundError(\"Cannot find job JSON file in working directory\")\n\n# Read job configuration\nwith open(job_file, 'r') as f:\n    job_data = json.load(f)\n\n# Get materials from job data\n# Materials can be in 'materials' or '_materials' field\nmaterials = job_data.get('materials', job_data.get('_materials', []))\n\nif not materials or material_index >= len(materials):\n    raise ValueError(f\"Material index {material_index} not found. Available: {len(materials)} materials\")\n\nmaterial = materials[material_index]\n\n# Extract basis coordinates\nbasis = material.get('basis', {})\ncoordinates = basis.get('coordinates', [])\nelements = basis.get('elements', [])\n\n# Get z-coordinates (fractional by default)\nz_coords_frac = []\nfor coord in coordinates:\n    value = coord.get('value', [0, 0, 0])\n    z_coords_frac.append(value[2])\n\nz_coords_frac = np.array(z_coords_frac)\n\n# Get lattice c parameter\nlattice = material.get('lattice', {})\nc_length = lattice.get('c', 1.0)\n\n# Check coordinate units\nunits = basis.get('units', 'crystal')\nif units == 'crystal':\n    # Fractional - convert to Angstroms\n    z_coords_angstrom = z_coords_frac * c_length\nelse:\n    # Already in Angstroms\n    z_coords_angstrom = z_coords_frac\n\n# Extract z-range\nz_min = float(np.min(z_coords_angstrom))\nz_max = float(np.max(z_coords_angstrom))\n\nresult = {\n    \"z_min\": z_min,\n    \"z_max\": z_max,\n    \"material_index\": material_index,\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "extract_slab_coordinates.py",
                            "rendered": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nExtract z-coordinate boundaries from materials for polar VBO calculation.\n\nReads material data from the job JSON file in the working directory.\nThis is more reliable than reading from pw_scf.out which may be overwritten\nin multi-material workflows.\n\"\"\"\nimport json\nimport os\nimport glob\n\nimport numpy as np\n\n# Material index: 0=Interface, 1=Left, 2=Right\nmaterial_index = int({{material_index}})\n\n# Find the job JSON file in the current directory\n# It's typically named with the job slug (e.g., \"abc123def.json\")\njson_files = glob.glob(\"*.json\")\njob_file = None\nfor f in json_files:\n    # Skip result files and other known non-job files\n    if f.startswith(\"result\") or f.startswith(\"properties\"):\n        continue\n    # The job file typically has a slug-like name (alphanumeric)\n    basename = os.path.splitext(f)[0]\n    if basename.isalnum() and len(basename) > 10:\n        job_file = f\n        break\n\nif job_file is None:\n    raise FileNotFoundError(\"Cannot find job JSON file in working directory\")\n\n# Read job configuration\nwith open(job_file, 'r') as f:\n    job_data = json.load(f)\n\n# Get materials from job data\n# Materials can be in 'materials' or '_materials' field\nmaterials = job_data.get('materials', job_data.get('_materials', []))\n\nif not materials or material_index >= len(materials):\n    raise ValueError(f\"Material index {material_index} not found. Available: {len(materials)} materials\")\n\nmaterial = materials[material_index]\n\n# Extract basis coordinates\nbasis = material.get('basis', {})\ncoordinates = basis.get('coordinates', [])\nelements = basis.get('elements', [])\n\n# Get z-coordinates (fractional by default)\nz_coords_frac = []\nfor coord in coordinates:\n    value = coord.get('value', [0, 0, 0])\n    z_coords_frac.append(value[2])\n\nz_coords_frac = np.array(z_coords_frac)\n\n# Get lattice c parameter\nlattice = material.get('lattice', {})\nc_length = lattice.get('c', 1.0)\n\n# Check coordinate units\nunits = basis.get('units', 'crystal')\nif units == 'crystal':\n    # Fractional - convert to Angstroms\n    z_coords_angstrom = z_coords_frac * c_length\nelse:\n    # Already in Angstroms\n    z_coords_angstrom = z_coords_frac\n\n# Extract z-range\nz_min = float(np.min(z_coords_angstrom))\nz_max = float(np.max(z_coords_angstrom))\n\nresult = {\n    \"z_min\": z_min,\n    \"z_max\": z_max,\n    \"material_index\": material_index,\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\nmat3ra-made[tools]>=2024.11.12.0\n\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\nmat3ra-made[tools]>=2024.11.12.0\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "83a497a3-98ef-56c6-8645-2ed81aea47df"
                },
                {
                    "name": "Parse Coordinate Results",
                    "type": "assignment",
                    "operand": "COORDS",
                    "value": "json.loads(STDOUT)",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-extract-coords-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "83a497a3-98ef-56c6-8645-2ed81aea47df",
                    "tags": [],
                    "head": false,
                    "next": "2dd3de29-111a-5315-bc0c-5cbc45fab7d7",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab1 Min Coordinate",
                    "type": "assignment",
                    "operand": "slab1_min",
                    "value": "COORDS['z_min']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "2dd3de29-111a-5315-bc0c-5cbc45fab7d7",
                    "tags": [],
                    "head": false,
                    "next": "9052b78f-56ab-587f-a5e0-5cd15ff81a61",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab1 Max Coordinate",
                    "type": "assignment",
                    "operand": "slab1_max",
                    "value": "COORDS['z_max']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "9052b78f-56ab-587f-a5e0-5cd15ff81a61",
                    "tags": [],
                    "head": false,
                    "next": "3dc86d2e-680e-561c-a9f3-f58144656567",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab2 Min Coordinate",
                    "type": "assignment",
                    "operand": "slab2_min",
                    "value": "COORDS['z_min']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "3dc86d2e-680e-561c-a9f3-f58144656567",
                    "tags": [],
                    "head": false,
                    "next": "9a3c8610-67ee-5954-aa9d-c9f6fe0b9c29",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab2 Max Coordinate",
                    "type": "assignment",
                    "operand": "slab2_max",
                    "value": "COORDS['z_max']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "9a3c8610-67ee-5954-aa9d-c9f6fe0b9c29",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "06555e5f-08b8-5966-91b6-5ec296bf5fdf",
            "name": "BS + Avg ESP (Interface Right)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface Right)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "2",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "e7f14fe8-eb8c-54da-bb9f-6cac13b25b54",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-right"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM_RIGHT",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential-right"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "next": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set ESP Profile to Global Scope",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "30295ace-5fae-5d7e-bfa3-fb553172e9d8",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "bde0534e-171c-5108-a2bc-f7a15a956e79",
            "name": "Extract Right Coordinates",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Set Material Index",
                    "type": "assignment",
                    "operand": "material_index",
                    "value": "2",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "2d360607-c739-54ad-97a0-8a83f0971f2c",
                    "tags": [],
                    "head": true,
                    "next": "python-extract-coords-right",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "Extract Z-Coordinates from Material",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-extract-coords-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "extract_slab_coordinates.py",
                                "templateName": "extract_slab_coordinates.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "requirements_with_made.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "generic:processing:extract_slab_coordinates",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nExtract z-coordinate boundaries from materials for polar VBO calculation.\n\nReads material data from the job JSON file in the working directory.\nThis is more reliable than reading from pw_scf.out which may be overwritten\nin multi-material workflows.\n\"\"\"\nimport json\nimport os\nimport glob\n\nimport numpy as np\n\n# Material index: 0=Interface, 1=Left, 2=Right\n{% raw %}material_index = int({{material_index}}){% endraw %}\n\n# Find the job JSON file in the current directory\n# It's typically named with the job slug (e.g., \"abc123def.json\")\njson_files = glob.glob(\"*.json\")\njob_file = None\nfor f in json_files:\n    # Skip result files and other known non-job files\n    if f.startswith(\"result\") or f.startswith(\"properties\"):\n        continue\n    # The job file typically has a slug-like name (alphanumeric)\n    basename = os.path.splitext(f)[0]\n    if basename.isalnum() and len(basename) > 10:\n        job_file = f\n        break\n\nif job_file is None:\n    raise FileNotFoundError(\"Cannot find job JSON file in working directory\")\n\n# Read job configuration\nwith open(job_file, 'r') as f:\n    job_data = json.load(f)\n\n# Get materials from job data\n# Materials can be in 'materials' or '_materials' field\nmaterials = job_data.get('materials', job_data.get('_materials', []))\n\nif not materials or material_index >= len(materials):\n    raise ValueError(f\"Material index {material_index} not found. Available: {len(materials)} materials\")\n\nmaterial = materials[material_index]\n\n# Extract basis coordinates\nbasis = material.get('basis', {})\ncoordinates = basis.get('coordinates', [])\nelements = basis.get('elements', [])\n\n# Get z-coordinates (fractional by default)\nz_coords_frac = []\nfor coord in coordinates:\n    value = coord.get('value', [0, 0, 0])\n    z_coords_frac.append(value[2])\n\nz_coords_frac = np.array(z_coords_frac)\n\n# Get lattice c parameter\nlattice = material.get('lattice', {})\nc_length = lattice.get('c', 1.0)\n\n# Check coordinate units\nunits = basis.get('units', 'crystal')\nif units == 'crystal':\n    # Fractional - convert to Angstroms\n    z_coords_angstrom = z_coords_frac * c_length\nelse:\n    # Already in Angstroms\n    z_coords_angstrom = z_coords_frac\n\n# Extract z-range\nz_min = float(np.min(z_coords_angstrom))\nz_max = float(np.max(z_coords_angstrom))\n\nresult = {\n    \"z_min\": z_min,\n    \"z_max\": z_max,\n    \"material_index\": material_index,\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "extract_slab_coordinates.py",
                            "rendered": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nExtract z-coordinate boundaries from materials for polar VBO calculation.\n\nReads material data from the job JSON file in the working directory.\nThis is more reliable than reading from pw_scf.out which may be overwritten\nin multi-material workflows.\n\"\"\"\nimport json\nimport os\nimport glob\n\nimport numpy as np\n\n# Material index: 0=Interface, 1=Left, 2=Right\nmaterial_index = int({{material_index}})\n\n# Find the job JSON file in the current directory\n# It's typically named with the job slug (e.g., \"abc123def.json\")\njson_files = glob.glob(\"*.json\")\njob_file = None\nfor f in json_files:\n    # Skip result files and other known non-job files\n    if f.startswith(\"result\") or f.startswith(\"properties\"):\n        continue\n    # The job file typically has a slug-like name (alphanumeric)\n    basename = os.path.splitext(f)[0]\n    if basename.isalnum() and len(basename) > 10:\n        job_file = f\n        break\n\nif job_file is None:\n    raise FileNotFoundError(\"Cannot find job JSON file in working directory\")\n\n# Read job configuration\nwith open(job_file, 'r') as f:\n    job_data = json.load(f)\n\n# Get materials from job data\n# Materials can be in 'materials' or '_materials' field\nmaterials = job_data.get('materials', job_data.get('_materials', []))\n\nif not materials or material_index >= len(materials):\n    raise ValueError(f\"Material index {material_index} not found. Available: {len(materials)} materials\")\n\nmaterial = materials[material_index]\n\n# Extract basis coordinates\nbasis = material.get('basis', {})\ncoordinates = basis.get('coordinates', [])\nelements = basis.get('elements', [])\n\n# Get z-coordinates (fractional by default)\nz_coords_frac = []\nfor coord in coordinates:\n    value = coord.get('value', [0, 0, 0])\n    z_coords_frac.append(value[2])\n\nz_coords_frac = np.array(z_coords_frac)\n\n# Get lattice c parameter\nlattice = material.get('lattice', {})\nc_length = lattice.get('c', 1.0)\n\n# Check coordinate units\nunits = basis.get('units', 'crystal')\nif units == 'crystal':\n    # Fractional - convert to Angstroms\n    z_coords_angstrom = z_coords_frac * c_length\nelse:\n    # Already in Angstroms\n    z_coords_angstrom = z_coords_frac\n\n# Extract z-range\nz_min = float(np.min(z_coords_angstrom))\nz_max = float(np.max(z_coords_angstrom))\n\nresult = {\n    \"z_min\": z_min,\n    \"z_max\": z_max,\n    \"material_index\": material_index,\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\nmat3ra-made[tools]>=2024.11.12.0\n\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\nmat3ra-made[tools]>=2024.11.12.0\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "83a497a3-98ef-56c6-8645-2ed81aea47df"
                },
                {
                    "name": "Parse Coordinate Results",
                    "type": "assignment",
                    "operand": "COORDS",
                    "value": "json.loads(STDOUT)",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-extract-coords-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "83a497a3-98ef-56c6-8645-2ed81aea47df",
                    "tags": [],
                    "head": false,
                    "next": "2dd3de29-111a-5315-bc0c-5cbc45fab7d7",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab1 Min Coordinate",
                    "type": "assignment",
                    "operand": "slab1_min",
                    "value": "COORDS['z_min']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "2dd3de29-111a-5315-bc0c-5cbc45fab7d7",
                    "tags": [],
                    "head": false,
                    "next": "9052b78f-56ab-587f-a5e0-5cd15ff81a61",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab1 Max Coordinate",
                    "type": "assignment",
                    "operand": "slab1_max",
                    "value": "COORDS['z_max']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "9052b78f-56ab-587f-a5e0-5cd15ff81a61",
                    "tags": [],
                    "head": false,
                    "next": "3dc86d2e-680e-561c-a9f3-f58144656567",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab2 Min Coordinate",
                    "type": "assignment",
                    "operand": "slab2_min",
                    "value": "COORDS['z_min']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "3dc86d2e-680e-561c-a9f3-f58144656567",
                    "tags": [],
                    "head": false,
                    "next": "9a3c8610-67ee-5954-aa9d-c9f6fe0b9c29",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Slab2 Max Coordinate",
                    "type": "assignment",
                    "operand": "slab2_max",
                    "value": "COORDS['z_max']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "9a3c8610-67ee-5954-aa9d-c9f6fe0b9c29",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "c9192ba7-ce76-5bc7-a156-7029de146550",
            "name": "Fit Polar ESP (Interface)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "file_content"
            ],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Import Average Potential Profile",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a094e53f-3a7b-5986-a82d-6c0aeea7d1e1",
                    "tags": [],
                    "head": true,
                    "next": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Min",
                    "type": "assignment",
                    "operand": "slab1_min",
                    "value": "slab1_min",
                    "input": [
                        {
                            "name": "slab1_min",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "tags": [],
                    "head": false,
                    "next": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Max",
                    "type": "assignment",
                    "operand": "slab1_max",
                    "value": "slab1_max",
                    "input": [
                        {
                            "name": "slab1_max",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "tags": [],
                    "head": false,
                    "next": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Min",
                    "type": "assignment",
                    "operand": "slab2_min",
                    "value": "slab2_min",
                    "input": [
                        {
                            "name": "slab2_min",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "tags": [],
                    "head": false,
                    "next": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Max",
                    "type": "assignment",
                    "operand": "slab2_max",
                    "value": "slab2_max",
                    "input": [
                        {
                            "name": "slab2_max",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "tags": [],
                    "head": false,
                    "next": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Interface Part Label",
                    "type": "assignment",
                    "operand": "interface_part",
                    "value": "'Interface'",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "tags": [],
                    "head": false,
                    "next": "python-fit-esp-polar-interface",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "Fit Linear ESP for Polar Interface",
                    "head": false,
                    "results": [
                        {
                            "name": "file_content"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-interface",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "file_content"
                        ],
                        "name": "espresso:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\n{% raw %}profile = {{average_potential_profile}}{% endraw %}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\n{% raw %}SLAB1_MIN = float({{slab1_min}}){% endraw %}\n{% raw %}SLAB1_MAX = float({{slab1_max}}){% endraw %}\n{% raw %}SLAB2_MIN = float({{slab2_min}}){% endraw %}\n{% raw %}SLAB2_MAX = float({{slab2_max}}){% endraw %}\n\n# Interface part for labeling output files (Interface, Left, or Right)\n{% raw %}INTERFACE_PART = \"{{interface_part}}\"{% endraw %}\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\nprofile = {{average_potential_profile}}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\nSLAB1_MIN = float({{slab1_min}})\nSLAB1_MAX = float({{slab1_max}})\nSLAB2_MIN = float({{slab2_min}})\nSLAB2_MAX = float({{slab2_max}})\n\n# Interface part for labeling output files (Interface, Left, or Right)\nINTERFACE_PART = \"{{interface_part}}\"\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "8fce780b-5555-5b73-b3d1-1bb24a4c759d"
                },
                {
                    "name": "Set Average ESP Value",
                    "type": "assignment",
                    "operand": "AVG_ESP_INTERFACE",
                    "value": "json.loads(STDOUT)['minima']",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-interface"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "8fce780b-5555-5b73-b3d1-1bb24a4c759d",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "a9699729-298a-5e5f-9f6e-3e7b3b694a6e",
            "name": "Fit Polar ESP (Interface Left)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "file_content"
            ],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Import Average Potential Profile",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a094e53f-3a7b-5986-a82d-6c0aeea7d1e1",
                    "tags": [],
                    "head": true,
                    "next": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Min",
                    "type": "assignment",
                    "operand": "slab1_min",
                    "value": "slab1_min",
                    "input": [
                        {
                            "name": "slab1_min",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "tags": [],
                    "head": false,
                    "next": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Max",
                    "type": "assignment",
                    "operand": "slab1_max",
                    "value": "slab1_max",
                    "input": [
                        {
                            "name": "slab1_max",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "tags": [],
                    "head": false,
                    "next": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Min",
                    "type": "assignment",
                    "operand": "slab2_min",
                    "value": "slab2_min",
                    "input": [
                        {
                            "name": "slab2_min",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "tags": [],
                    "head": false,
                    "next": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Max",
                    "type": "assignment",
                    "operand": "slab2_max",
                    "value": "slab2_max",
                    "input": [
                        {
                            "name": "slab2_max",
                            "scope": "Extract Left Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "tags": [],
                    "head": false,
                    "next": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Interface Part Label",
                    "type": "assignment",
                    "operand": "interface_part",
                    "value": "'Left'",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "tags": [],
                    "head": false,
                    "next": "python-fit-esp-polar-left",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "Fit Linear ESP for Polar Interface",
                    "head": false,
                    "results": [
                        {
                            "name": "file_content"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "file_content"
                        ],
                        "name": "espresso:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\n{% raw %}profile = {{average_potential_profile}}{% endraw %}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\n{% raw %}SLAB1_MIN = float({{slab1_min}}){% endraw %}\n{% raw %}SLAB1_MAX = float({{slab1_max}}){% endraw %}\n{% raw %}SLAB2_MIN = float({{slab2_min}}){% endraw %}\n{% raw %}SLAB2_MAX = float({{slab2_max}}){% endraw %}\n\n# Interface part for labeling output files (Interface, Left, or Right)\n{% raw %}INTERFACE_PART = \"{{interface_part}}\"{% endraw %}\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\nprofile = {{average_potential_profile}}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\nSLAB1_MIN = float({{slab1_min}})\nSLAB1_MAX = float({{slab1_max}})\nSLAB2_MIN = float({{slab2_min}})\nSLAB2_MAX = float({{slab2_max}})\n\n# Interface part for labeling output files (Interface, Left, or Right)\nINTERFACE_PART = \"{{interface_part}}\"\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "8fce780b-5555-5b73-b3d1-1bb24a4c759d"
                },
                {
                    "name": "Set Average ESP Value",
                    "type": "assignment",
                    "operand": "AVG_ESP_LEFT",
                    "value": "json.loads(STDOUT)['minima']",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "8fce780b-5555-5b73-b3d1-1bb24a4c759d",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "0b8d0aca-ccd7-55c7-8bf9-2970792cee12",
            "name": "Fit Polar ESP (Interface Right)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "file_content"
            ],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Import Average Potential Profile",
                    "type": "assignment",
                    "operand": "average_potential_profile",
                    "value": "average_potential_profile",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a094e53f-3a7b-5986-a82d-6c0aeea7d1e1",
                    "tags": [],
                    "head": true,
                    "next": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Min",
                    "type": "assignment",
                    "operand": "slab1_min",
                    "value": "slab1_min",
                    "input": [
                        {
                            "name": "slab1_min",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "e4a082aa-a35f-59c7-a13c-37d168c80874",
                    "tags": [],
                    "head": false,
                    "next": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab1 Max",
                    "type": "assignment",
                    "operand": "slab1_max",
                    "value": "slab1_max",
                    "input": [
                        {
                            "name": "slab1_max",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "cbaaec65-b89d-5acd-ad82-bb272f49581d",
                    "tags": [],
                    "head": false,
                    "next": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Min",
                    "type": "assignment",
                    "operand": "slab2_min",
                    "value": "slab2_min",
                    "input": [
                        {
                            "name": "slab2_min",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "564e20c0-d40e-5113-939d-b273ffec743a",
                    "tags": [],
                    "head": false,
                    "next": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Import Slab2 Max",
                    "type": "assignment",
                    "operand": "slab2_max",
                    "value": "slab2_max",
                    "input": [
                        {
                            "name": "slab2_max",
                            "scope": "Extract Right Coordinates"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "d3612ae8-99ea-5df1-9c28-cda4bc4e5aca",
                    "tags": [],
                    "head": false,
                    "next": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Interface Part Label",
                    "type": "assignment",
                    "operand": "interface_part",
                    "value": "'Right'",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "6270f60d-ee9e-53cf-8c61-d250bf8f7cb2",
                    "tags": [],
                    "head": false,
                    "next": "python-fit-esp-polar-right",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "Fit Linear ESP for Polar Interface",
                    "head": false,
                    "results": [
                        {
                            "name": "file_content"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "file_content"
                        ],
                        "name": "espresso:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\n{% raw %}profile = {{average_potential_profile}}{% endraw %}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\n{% raw %}SLAB1_MIN = float({{slab1_min}}){% endraw %}\n{% raw %}SLAB1_MAX = float({{slab1_max}}){% endraw %}\n{% raw %}SLAB2_MIN = float({{slab2_min}}){% endraw %}\n{% raw %}SLAB2_MAX = float({{slab2_max}}){% endraw %}\n\n# Interface part for labeling output files (Interface, Left, or Right)\n{% raw %}INTERFACE_PART = \"{{interface_part}}\"{% endraw %}\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport matplotlib\nmatplotlib.use('Agg')  # Non-interactive backend for headless environments\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\nprofile = {{average_potential_profile}}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\nSLAB1_MIN = float({{slab1_min}})\nSLAB1_MAX = float({{slab1_max}})\nSLAB2_MIN = float({{slab2_min}})\nSLAB2_MAX = float({{slab2_max}})\n\n# Interface part for labeling output files (Interface, Left, or Right)\nINTERFACE_PART = \"{{interface_part}}\"\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value, slope, and intercept.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        avg = float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n        return avg, 0.0, avg\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value), float(slope), float(intercept)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa, slope_a, intercept_a = fit_and_average(X, Y, slab1_start, slab1_end)\nVb, slope_b, intercept_b = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n\n# Generate visualization plot\nplt.figure(figsize=(10, 6))\nplt.plot(X, Y, label='Macroscopic Average Potential', linewidth=2)\n\n# Highlight fitting regions\nplt.axvspan(SLAB1_MIN, SLAB1_MAX, color='red', alpha=0.2, label='Slab 1 Region')\nplt.axvspan(SLAB2_MIN, SLAB2_MAX, color='blue', alpha=0.2, label='Slab 2 Region')\n\n# Plot fitted lines\nif slab1_end > slab1_start:\n    x_fit1 = X[slab1_start:slab1_end]\n    y_fit1 = slope_a * x_fit1 + intercept_a\n    plt.plot(x_fit1, y_fit1, color='darkred', linestyle='--', linewidth=2, label='Fit Slab 1')\n\nif slab2_end > slab2_start:\n    x_fit2 = X[slab2_start:slab2_end]\n    y_fit2 = slope_b * x_fit2 + intercept_b\n    plt.plot(x_fit2, y_fit2, color='darkblue', linestyle='--', linewidth=2, label='Fit Slab 2')\n\n# Plot average ESP values\nplt.axhline(Va, color='red', linestyle=':', linewidth=2, label=f'Avg ESP Slab 1 = {Va:.3f} eV')\nplt.axhline(Vb, color='blue', linestyle=':', linewidth=2, label=f'Avg ESP Slab 2 = {Vb:.3f} eV')\n\nplt.xlabel('z-coordinate ()', fontsize=12)\nplt.ylabel('Macroscopic Average Potential (eV)', fontsize=12)\nplt.title(f'Polar Interface VBO Calculation', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n# Save plot to file with interface part in filename\nfilename = f'polar_vbo_fit_{INTERFACE_PART}.png'\nplt.savefig(filename, dpi=150, bbox_inches='tight')\nplt.close()\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "8fce780b-5555-5b73-b3d1-1bb24a4c759d"
                },
                {
                    "name": "Set Average ESP Value",
                    "type": "assignment",
                    "operand": "AVG_ESP_RIGHT",
                    "value": "json.loads(STDOUT)['minima']",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "8fce780b-5555-5b73-b3d1-1bb24a4c759d",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "1b70e606-a7ee-599e-89e0-91a7dc5faa4a",
            "name": "Calculate VBO",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "valence_band_offset"
            ],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Difference of valence band maxima",
                    "type": "assignment",
                    "operand": "VBM_DIFF",
                    "value": "VBM_LEFT - VBM_RIGHT",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "bd4eaa98-b001-5694-87ef-ec77540502ab",
                    "tags": [],
                    "head": true,
                    "next": "2626f7bb-d392-5fd4-ab71-329b508de347",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Difference of macroscopically averaged ESP in bulk",
                    "type": "assignment",
                    "operand": "AVG_ESP_DIFF",
                    "value": "AVG_ESP_LEFT[0] - AVG_ESP_RIGHT[0]",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "2626f7bb-d392-5fd4-ab71-329b508de347",
                    "tags": [],
                    "head": false,
                    "next": "b7307787-53e2-599b-ad12-d627b04074b4",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Lineup of macroscopically averaged ESP in interface",
                    "type": "assignment",
                    "operand": "ESP_LINEUP",
                    "value": "np.abs(AVG_ESP_INTERFACE[0] - AVG_ESP_INTERFACE[1])",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "b7307787-53e2-599b-ad12-d627b04074b4",
                    "tags": [],
                    "head": false,
                    "next": "197f4b4d-cb7b-57be-a885-d44cb1f61905",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Valence Band Offset",
                    "type": "assignment",
                    "operand": "VALENCE_BAND_OFFSET",
                    "value": "abs(VBM_DIFF - AVG_ESP_DIFF + (np.sign(AVG_ESP_DIFF) * ESP_LINEUP))",
                    "input": [],
                    "results": [
                        {
                            "name": "valence_band_offset"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "197f4b4d-cb7b-57be-a885-d44cb1f61905",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        }
    ],
    "units": [
        {
            "name": "BS + Avg ESP (Interface)",
            "type": "subworkflow",
            "_id": "9c65d03e-6a30-58f3-947a-f174342be0c3",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "fd622b5c-5c02-594e-b582-b245c17ca9a4",
            "tags": [],
            "head": true,
            "next": "2eb30f49-5dcb-593c-b389-ac763e7df7aa"
        },
        {
            "name": "BS + Avg ESP (Interface Left)",
            "type": "subworkflow",
            "_id": "438d67a5-7f5f-5e02-93ee-a72cb282af06",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "2eb30f49-5dcb-593c-b389-ac763e7df7aa",
            "tags": [],
            "head": false,
            "next": "03760b7f-0085-5dce-945f-347eb639780f"
        },
        {
            "name": "Extract Left Coordinates",
            "type": "subworkflow",
            "_id": "8d784c4d-93f6-5ff4-9cbc-c166c8709e93",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "03760b7f-0085-5dce-945f-347eb639780f",
            "tags": [],
            "head": false,
            "next": "a86171a8-2b72-531d-a1cc-0ed3f03797af"
        },
        {
            "name": "BS + Avg ESP (Interface Right)",
            "type": "subworkflow",
            "_id": "06555e5f-08b8-5966-91b6-5ec296bf5fdf",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "a86171a8-2b72-531d-a1cc-0ed3f03797af",
            "tags": [],
            "head": false,
            "next": "b6597e42-a6aa-5257-bf81-c7825f3b0c7c"
        },
        {
            "name": "Extract Right Coordinates",
            "type": "subworkflow",
            "_id": "bde0534e-171c-5108-a2bc-f7a15a956e79",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "b6597e42-a6aa-5257-bf81-c7825f3b0c7c",
            "tags": [],
            "head": false,
            "next": "67770422-0b81-5bbe-b2ba-355a5f920499"
        },
        {
            "name": "Fit Polar ESP (Interface)",
            "type": "subworkflow",
            "_id": "c9192ba7-ce76-5bc7-a156-7029de146550",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "67770422-0b81-5bbe-b2ba-355a5f920499",
            "tags": [],
            "head": false,
            "next": "f0e75e9e-cc3e-5224-a2e2-81ba4d2ef581"
        },
        {
            "name": "Fit Polar ESP (Interface Left)",
            "type": "subworkflow",
            "_id": "a9699729-298a-5e5f-9f6e-3e7b3b694a6e",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "f0e75e9e-cc3e-5224-a2e2-81ba4d2ef581",
            "tags": [],
            "head": false,
            "next": "bf6caeb4-db41-58c5-995c-3874b728eaa6"
        },
        {
            "name": "Fit Polar ESP (Interface Right)",
            "type": "subworkflow",
            "_id": "0b8d0aca-ccd7-55c7-8bf9-2970792cee12",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "bf6caeb4-db41-58c5-995c-3874b728eaa6",
            "tags": [],
            "head": false,
            "next": "0e0b141a-39ca-52bc-9094-e5f96dc72f39"
        },
        {
            "name": "Calculate VBO",
            "type": "subworkflow",
            "_id": "1b70e606-a7ee-599e-89e0-91a7dc5faa4a",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "0e0b141a-39ca-52bc-9094-e5f96dc72f39",
            "tags": [],
            "head": false
        }
    ],
    "properties": [
        "atomic_forces",
        "average_potential_profile",
        "band_gaps",
        "fermi_energy",
        "pressure",
        "stress_tensor",
        "total_energy",
        "total_energy_contributions",
        "total_force"
    ],
    "_id": "d8e08cac-7747-50aa-b925-41f214d722c6",
    "workflows": [],
    "schemaVersion": "2022.8.16",
    "isDefault": false,
    "application": {
        "name": "espresso"
    }
}
