{
    "_id": "e5bee93f-2b6b-5d91-9a53-5ed309a918d3",
    "name": "Find ESP Value",
    "application": {
        "name": "espresso"
    },
    "properties": [],
    "model": {
        "type": "unknown",
        "subtype": "unknown",
        "method": {
            "type": "unknown",
            "subtype": "unknown",
            "data": {}
        }
    },
    "units": [
        {
            "type": "execution",
            "name": "Fit ESP Linear Regions",
            "head": true,
            "results": [],
            "monitors": [
                {
                    "name": "standard_output"
                }
            ],
            "flowchartId": "python-fit-esp-polar",
            "preProcessors": [],
            "postProcessors": [],
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "executable": {
                "isDefault": true,
                "monitors": [
                    "standard_output"
                ],
                "name": "python",
                "schemaVersion": "2022.8.16"
            },
            "flavor": {
                "applicationName": "python",
                "executableName": "python",
                "input": [
                    {
                        "name": "fit_esp_polar.py",
                        "templateName": "fit_esp_polar.py"
                    },
                    {
                        "name": "requirements.txt",
                        "templateName": "processing_requirements.txt"
                    }
                ],
                "monitors": [
                    "standard_output"
                ],
                "name": "espresso:processing:fit_esp_polar",
                "schemaVersion": "2022.8.16",
                "isDefault": false
            },
            "status": "idle",
            "statusTrack": [],
            "tags": [],
            "input": [
                {
                    "applicationName": "python",
                    "content": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ESP values by extrapolating fitted lines to the interface.         #\n#                                                                    #\n# Output format is compatible with find_extrema.pyi to enable        #\n# drop-in replacement in VBO workflows.                              #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# For non-polar interfaces, slope ≈ 0 and this reduces to flat avg. #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\n{% raw %}Y = np.array({{array_from_context}}){% endraw %}\n{% raw %}{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}{% endraw %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10  # Exclude 10% from edges to avoid surface effects\nMIN_REGION_POINTS = 10  # Minimum points needed for linear fit\n\n\ndef detect_interface_position(y_data, x_data):\n    \"\"\"Find interface position by locating maximum gradient in ESP profile.\n    \n    Uses gradient smoothing to identify the steepest change, which indicates\n    the interface between two materials.\n    \"\"\"\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    \n    # Calculate smoothed gradient to find interface\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    \n    # Search for maximum gradient (interface) excluding margins\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    \"\"\"Determine bulk-like regions on left and right sides for linear fitting.\n    \n    Ensures regions are far enough from interface and edges to capture\n    representative bulk behavior.\n    \"\"\"\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    \n    # Left bulk region: between left margin and interface\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    \n    # Right bulk region: between interface and right margin\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    \n    # Ensure bounds are valid\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    \n    # Final fallback for edge cases\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    \n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    \"\"\"Fit linear regression to ESP data in specified region.\n    \n    Returns slope and intercept. For non-polar materials, slope ≈ 0.\n    For polar materials, slope represents internal electric field.\n    \"\"\"\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    \n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    # Fallback for insufficient data: return flat line at mean\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0}\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2}\n\n\n# Main calculation: fit lines to bulk regions and extrapolate to interface\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\n\n# Extrapolate fitted lines to interface position to get ESP values\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\n\n# Output in same format as find_extrema.pyi for compatibility\nresult = {\n    \"minima\": [float(left_value_at_interface), float(right_value_at_interface)],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n",
                    "contextProviders": [],
                    "executableName": "python",
                    "name": "fit_esp_polar.py",
                    "rendered": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ESP values by extrapolating fitted lines to the interface.         #\n#                                                                    #\n# Output format is compatible with find_extrema.pyi to enable        #\n# drop-in replacement in VBO workflows.                              #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# For non-polar interfaces, slope ≈ 0 and this reduces to flat avg. #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\nY = np.array({{array_from_context}})\n{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10  # Exclude 10% from edges to avoid surface effects\nMIN_REGION_POINTS = 10  # Minimum points needed for linear fit\n\n\ndef detect_interface_position(y_data, x_data):\n    \"\"\"Find interface position by locating maximum gradient in ESP profile.\n    \n    Uses gradient smoothing to identify the steepest change, which indicates\n    the interface between two materials.\n    \"\"\"\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    \n    # Calculate smoothed gradient to find interface\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    \n    # Search for maximum gradient (interface) excluding margins\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    \"\"\"Determine bulk-like regions on left and right sides for linear fitting.\n    \n    Ensures regions are far enough from interface and edges to capture\n    representative bulk behavior.\n    \"\"\"\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    \n    # Left bulk region: between left margin and interface\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    \n    # Right bulk region: between interface and right margin\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    \n    # Ensure bounds are valid\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    \n    # Final fallback for edge cases\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    \n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    \"\"\"Fit linear regression to ESP data in specified region.\n    \n    Returns slope and intercept. For non-polar materials, slope ≈ 0.\n    For polar materials, slope represents internal electric field.\n    \"\"\"\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    \n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    # Fallback for insufficient data: return flat line at mean\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0}\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2}\n\n\n# Main calculation: fit lines to bulk regions and extrapolate to interface\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\n\n# Extrapolate fitted lines to interface position to get ESP values\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\n\n# Output in same format as find_extrema.pyi for compatibility\nresult = {\n    \"minima\": [float(left_value_at_interface), float(right_value_at_interface)],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n",
                    "schemaVersion": "2022.8.16"
                },
                {
                    "applicationName": "python",
                    "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                    "contextProviders": [],
                    "executableName": "python",
                    "name": "requirements.txt",
                    "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                    "schemaVersion": "2022.8.16"
                }
            ],
            "next": "8fce780b-5555-5b73-b3d1-1bb24a4c759d"
        },
        {
            "name": "Set Average ESP Value",
            "type": "assignment",
            "operand": "AVG_ESP",
            "value": "json.loads(STDOUT)['minima']",
            "input": [
                {
                    "name": "STDOUT",
                    "scope": "python-fit-esp-polar"
                }
            ],
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "8fce780b-5555-5b73-b3d1-1bb24a4c759d",
            "tags": [],
            "head": false,
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            }
        }
    ]
}
