{
    "name": "Valence Band Offset (Polar Interface)",
    "subworkflows": [
        {
            "isMultiMaterial": true,
            "_id": "9c65d03e-6a30-58f3-947a-f174342be0c3",
            "name": "BS + Avg ESP (Interface)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "0",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "0f21d8c4-ab32-53ba-b40d-fc9b6608e1b9",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-right"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "c9192ba7-ce76-5bc7-a156-7029de146550",
            "name": "Fit Polar ESP (Interface)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "type": "execution",
                    "name": "Fit ESP Linear Regions",
                    "head": true,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-interface",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "generic:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\n{% raw %}Y = np.array({{array_from_context}}){% endraw %}\n{% raw %}{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}{% endraw %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\nY = np.array({{array_from_context}})\n{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "0c37a439-d4e4-5376-8c16-1557e99e969b"
                },
                {
                    "name": "Set Polar ESP Fit Result",
                    "type": "assignment",
                    "operand": "ESP_POLAR_FIT_INTERFACE",
                    "value": "json.loads(STDOUT)",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-interface"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "0c37a439-d4e4-5376-8c16-1557e99e969b",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "438d67a5-7f5f-5e02-93ee-a72cb282af06",
            "name": "BS + Avg ESP (Interface Left)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface Left)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "1",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "517eb13b-3632-502b-a32b-8c1e07746827",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-left"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM_LEFT",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential-left"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "a9699729-298a-5e5f-9f6e-3e7b3b694a6e",
            "name": "Fit Polar ESP (Interface Left)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "type": "execution",
                    "name": "Fit ESP Linear Regions",
                    "head": true,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-left",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "generic:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\n{% raw %}Y = np.array({{array_from_context}}){% endraw %}\n{% raw %}{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}{% endraw %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\nY = np.array({{array_from_context}})\n{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "0c37a439-d4e4-5376-8c16-1557e99e969b"
                },
                {
                    "name": "Set Polar ESP Fit Result",
                    "type": "assignment",
                    "operand": "ESP_POLAR_FIT_LEFT",
                    "value": "json.loads(STDOUT)",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "0c37a439-d4e4-5376-8c16-1557e99e969b",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "isMultiMaterial": true,
            "_id": "06555e5f-08b8-5966-91b6-5ec296bf5fdf",
            "name": "BS + Avg ESP (Interface Right)",
            "application": {
                "name": "espresso",
                "shortName": "qe",
                "summary": "Quantum ESPRESSO",
                "build": "GNU",
                "hasAdvancedComputeOptions": true,
                "isDefault": true,
                "version": "6.3",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "atomic_forces",
                "fermi_energy",
                "pressure",
                "stress_tensor",
                "total_energy",
                "total_energy_contributions",
                "total_force",
                "band_gaps",
                "average_potential_profile"
            ],
            "model": {
                "type": "dft",
                "subtype": "gga",
                "method": {
                    "type": "pseudopotential",
                    "subtype": "us",
                    "data": {}
                },
                "functional": {
                    "slug": "pbe"
                },
                "refiners": [],
                "modifiers": []
            },
            "units": [
                {
                    "name": "Set Material Index (Interface Right)",
                    "type": "assignment",
                    "operand": "MATERIAL_INDEX",
                    "value": "2",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "e7f14fe8-eb8c-54da-bb9f-6cac13b25b54",
                    "tags": [],
                    "head": true,
                    "next": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "pw_scf",
                    "head": false,
                    "results": [
                        {
                            "name": "atomic_forces"
                        },
                        {
                            "name": "fermi_energy"
                        },
                        {
                            "name": "pressure"
                        },
                        {
                            "name": "stress_tensor"
                        },
                        {
                            "name": "total_energy"
                        },
                        {
                            "name": "total_energy_contributions"
                        },
                        {
                            "name": "total_force"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        },
                        {
                            "name": "convergence_electronic"
                        }
                    ],
                    "flowchartId": "9fc7a088-5533-5f70-bb33-f676ec65f565",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_scf.in"
                            }
                        ],
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_electronic"
                        ],
                        "results": [
                            "atomic_forces",
                            "fermi_energy",
                            "pressure",
                            "stress_tensor",
                            "total_energy",
                            "total_energy_contributions",
                            "total_force"
                        ],
                        "name": "pw_scf",
                        "schemaVersion": "2022.8.16"
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{ input.RESTART_MODE }}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS automatic\n{% for d in kgrid.dimensions %}{{d}} {% endfor %}{% for s in kgrid.shifts %}{{s}} {% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KGridFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_scf.in",
                            "rendered": "&CONTROL\n    calculation = 'scf'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n    startingwfc = 'atomic+random'\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS automatic\n2 2 2 0 0 0 \n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "pw-bands-calculate-band-gap-right"
                },
                {
                    "type": "execution",
                    "name": "pw_bands",
                    "head": false,
                    "results": [
                        {
                            "name": "band_gaps"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "pw-bands-calculate-band-gap-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "monitors": [
                            "standard_output",
                            "convergence_ionic",
                            "convergence_electronic"
                        ],
                        "postProcessors": [
                            "remove_non_zero_weight_kpoints"
                        ],
                        "name": "pw.x",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pw.x",
                        "input": [
                            {
                                "name": "pw_bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "band_structure"
                        ],
                        "name": "pw_bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "{% if subworkflowContext.MATERIAL_INDEX %}\n{%- set input = input.perMaterial[subworkflowContext.MATERIAL_INDEX] -%}\n{% endif -%}\n&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = '{{input.RESTART_MODE}}'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    wfcdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    pseudo_dir = {% raw %}'{{ JOB_WORK_DIR }}/pseudo'{% endraw %}\n/\n&SYSTEM\n    ibrav = {{ input.IBRAV }}\n    nat = {{ input.NAT }}\n    ntyp = {{ input.NTYP }}\n    ecutwfc = {{ cutoffs.wavefunction }}\n    ecutrho = {{ cutoffs.density }}\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\n{{ input.ATOMIC_SPECIES }}\nATOMIC_POSITIONS crystal\n{{ input.ATOMIC_POSITIONS }}\nCELL_PARAMETERS angstrom\n{{ input.CELL_PARAMETERS }}\nK_POINTS crystal_b\n{{kpath.length}}\n{% for point in kpath -%}\n{% for d in point.coordinates %}{{d}} {% endfor -%}{{point.steps}}\n{% endfor %}\n",
                            "contextProviders": [
                                {
                                    "name": "KPathFormDataManager"
                                },
                                {
                                    "name": "QEPWXInputDataManager"
                                },
                                {
                                    "name": "PlanewaveCutoffDataManager"
                                }
                            ],
                            "executableName": "pw.x",
                            "name": "pw_bands.in",
                            "rendered": "&CONTROL\n    calculation = 'bands'\n    title = ''\n    verbosity = 'low'\n    restart_mode = 'from_scratch'\n    wf_collect = .true.\n    tstress = .true.\n    tprnfor = .true.\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    wfcdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    pseudo_dir = '{{ JOB_WORK_DIR }}/pseudo'\n/\n&SYSTEM\n    ibrav = 0\n    nat = 2\n    ntyp = 1\n    ecutwfc = 40\n    ecutrho = 200\n    occupations = 'smearing'\n    degauss = 0.005\n/\n&ELECTRONS\n    diagonalization = 'david'\n    diago_david_ndim = 4\n    diago_full_acc = .true.\n    mixing_beta = 0.3\n/\n&IONS\n/\n&CELL\n/\nATOMIC_SPECIES\nSi 28.0855 \nATOMIC_POSITIONS crystal\nSi     0.000000000    0.000000000    0.000000000 \nSi     0.250000000    0.250000000    0.250000000 \nCELL_PARAMETERS angstrom\n3.348920236 0.000000000 1.933500000\n1.116306745 3.157392278 1.933500000\n0.000000000 0.000000000 3.867000000\nK_POINTS crystal_b\n11\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.000000000    0.500000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.375000000    0.375000000    0.750000000 10\n   0.000000000    0.000000000    0.000000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.250000000    0.750000000 10\n   0.500000000    0.500000000    0.500000000 10\n   0.625000000    0.250000000    0.625000000 10\n   0.500000000    0.000000000    0.500000000 10\n\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "a667d9fd-35d5-5897-be0e-fa0247233649"
                },
                {
                    "name": "Select indirect band gap",
                    "type": "assignment",
                    "operand": "BAND_GAP_INDIRECT",
                    "value": "[bandgap for bandgap in band_gaps['values'] if bandgap['type'] == 'indirect'][0]",
                    "input": [
                        {
                            "name": "band_gaps",
                            "scope": "pw-bands-calculate-band-gap-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a667d9fd-35d5-5897-be0e-fa0247233649",
                    "tags": [],
                    "head": false,
                    "next": "08819369-b541-5b51-8a40-0ee135039482",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Set Valence Band Maximum",
                    "type": "assignment",
                    "operand": "VBM_RIGHT",
                    "value": "BAND_GAP_INDIRECT['eigenvalueValence']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "08819369-b541-5b51-8a40-0ee135039482",
                    "tags": [],
                    "head": false,
                    "next": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "type": "execution",
                    "name": "bands",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "771fbb40-ea80-5ba4-ae3f-6cd9a56c26e2",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "bands.x",
                        "input": [
                            {
                                "name": "bands.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "bands",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&BANDS\n    prefix = '__prefix__'\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    filband = {% raw %}'{{ JOB_WORK_DIR }}/bands.dat'{% endraw %}\n    no_overlap = .true.\n/\n",
                            "contextProviders": [],
                            "executableName": "bands.x",
                            "name": "bands.in",
                            "rendered": "&BANDS\n    prefix = '__prefix__'\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    filband = '{{ JOB_WORK_DIR }}/bands.dat'\n    no_overlap = .true.\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde"
                },
                {
                    "type": "execution",
                    "name": "Electrostatic Potential (ESP)",
                    "head": false,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "9ed927b1-3d84-5730-a6a8-1b1cfba39bde",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "pp.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "pp.x",
                        "input": [
                            {
                                "name": "pp_electrostatic_potential.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [],
                        "name": "pp_electrostatic_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "&INPUTPP\n    outdir = {% raw %}'{{ JOB_WORK_DIR }}/outdir'{% endraw %}\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "contextProviders": [],
                            "executableName": "pp.x",
                            "name": "pp_electrostatic_potential.in",
                            "rendered": "&INPUTPP\n    outdir = '{{ JOB_WORK_DIR }}/outdir'\n    prefix = '__prefix__'\n    filplot = 'pp.dat'\n    plot_num = 11\n/\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "average-electrostatic-potential-right"
                },
                {
                    "type": "execution",
                    "name": "average ESP",
                    "head": false,
                    "results": [
                        {
                            "name": "average_potential_profile"
                        }
                    ],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "average-electrostatic-potential-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "average.x",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "flavor": {
                        "applicationName": "espresso",
                        "executableName": "average.x",
                        "input": [
                            {
                                "name": "average.in"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "results": [
                            "average_potential_profile"
                        ],
                        "name": "average_potential",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "espresso",
                            "content": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "contextProviders": [],
                            "executableName": "average.x",
                            "name": "average.in",
                            "rendered": "1\npp.dat\n1.0\n3000\n3\n3.0000\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "c6c11873-91d7-5422-8302-3dcc1ce971e9"
                },
                {
                    "name": "Set Macroscopically Averaged ESP Data",
                    "type": "assignment",
                    "operand": "array_from_context",
                    "value": "average_potential_profile['yDataSeries'][1]",
                    "input": [
                        {
                            "name": "average_potential_profile",
                            "scope": "average-electrostatic-potential-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "c6c11873-91d7-5422-8302-3dcc1ce971e9",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "espresso",
                        "shortName": "qe",
                        "summary": "Quantum ESPRESSO",
                        "build": "GNU",
                        "hasAdvancedComputeOptions": true,
                        "isDefault": true,
                        "version": "6.3",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "0b8d0aca-ccd7-55c7-8bf9-2970792cee12",
            "name": "Fit Polar ESP (Interface Right)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "type": "execution",
                    "name": "Fit ESP Linear Regions",
                    "head": true,
                    "results": [],
                    "monitors": [
                        {
                            "name": "standard_output"
                        }
                    ],
                    "flowchartId": "python-fit-esp-polar-right",
                    "preProcessors": [],
                    "postProcessors": [],
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    },
                    "executable": {
                        "isDefault": true,
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "python",
                        "schemaVersion": "2022.8.16"
                    },
                    "flavor": {
                        "applicationName": "python",
                        "executableName": "python",
                        "input": [
                            {
                                "name": "fit_esp_polar.py",
                                "templateName": "fit_esp_polar.py"
                            },
                            {
                                "name": "requirements.txt",
                                "templateName": "processing_requirements.txt"
                            }
                        ],
                        "monitors": [
                            "standard_output"
                        ],
                        "name": "generic:processing:fit_esp_polar",
                        "schemaVersion": "2022.8.16",
                        "isDefault": false
                    },
                    "status": "idle",
                    "statusTrack": [],
                    "tags": [],
                    "input": [
                        {
                            "applicationName": "python",
                            "content": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\n{% raw %}Y = np.array({{array_from_context}}){% endraw %}\n{% raw %}{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}{% endraw %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "fit_esp_polar.py",
                            "rendered": "# ------------------------------------------------------------------ #\n# This script fits linear regression to macroscopically averaged ESP #\n# for polar interfaces, detecting interface position and calculating #\n# ΔV by extrapolating fitted lines to the interface.                 #\n#                                                                    #\n# For polar interfaces (e.g., AlN/GaN (001), GaAs (001)), the ESP    #\n# profile shows a slope due to internal electric field.              #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom scipy.stats import linregress\n\n\nY = np.array({{array_from_context}})\n{% if x_positions_from_context is defined %}\nX = np.array({{x_positions_from_context}})\n{% else %}\nX = np.linspace(0, 1, len(Y))\n{% endif %}\n\nN = len(Y)\nMARGIN_FRACTION = 0.10\nMIN_REGION_POINTS = 10\n\n\ndef detect_interface_position(y_data, x_data):\n    n = len(y_data)\n    margin = max(int(n * MARGIN_FRACTION), MIN_REGION_POINTS)\n    if 2 * margin >= n:\n        return x_data[n // 2], n // 2\n    gradient = np.abs(np.gradient(y_data))\n    window = max(n // 20, 3)\n    smoothed = np.convolve(gradient, np.ones(window) / window, mode=\"same\")\n    search_start = margin\n    search_end = n - margin\n    search_region = smoothed[search_start:search_end]\n    if len(search_region) == 0:\n        return x_data[n // 2], n // 2\n    interface_idx = search_start + np.argmax(search_region)\n    return x_data[interface_idx], interface_idx\n\n\ndef get_bulk_regions(n_points, interface_idx):\n    margin = max(int(n_points * MARGIN_FRACTION), MIN_REGION_POINTS // 2)\n    left_start = margin\n    left_end = max(left_start + MIN_REGION_POINTS, interface_idx - margin)\n    if left_end <= left_start:\n        left_end = min(interface_idx, left_start + MIN_REGION_POINTS)\n    right_start = min(interface_idx + margin, n_points - margin - MIN_REGION_POINTS)\n    right_end = n_points - margin\n    if right_end <= right_start:\n        right_start = max(interface_idx, right_end - MIN_REGION_POINTS)\n    left_start = max(0, left_start)\n    left_end = min(n_points, left_end)\n    right_start = max(0, right_start)\n    right_end = min(n_points, right_end)\n    if left_end <= left_start:\n        left_start = 0\n        left_end = min(MIN_REGION_POINTS, interface_idx)\n    if right_end <= right_start:\n        right_start = max(interface_idx, n_points - MIN_REGION_POINTS)\n        right_end = n_points\n    return (left_start, left_end), (right_start, right_end)\n\n\ndef fit_linear_region(x_data, y_data, start_idx, end_idx):\n    start_idx = max(0, int(start_idx))\n    end_idx = min(len(x_data), int(end_idx))\n    if end_idx <= start_idx:\n        end_idx = start_idx + MIN_REGION_POINTS\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    if len(x_region) < 2:\n        return {\"slope\": 0.0, \"intercept\": float(np.mean(y_data)), \"r_squared\": 0.0, \"std_err\": 0.0}\n    slope, intercept, r_value, _, std_err = linregress(x_region, y_region)\n    return {\"slope\": slope, \"intercept\": intercept, \"r_squared\": r_value**2, \"std_err\": std_err}\n\n\ninterface_x, interface_idx = detect_interface_position(Y, X)\nleft_region, right_region = get_bulk_regions(N, interface_idx)\nleft_fit = fit_linear_region(X, Y, left_region[0], left_region[1])\nright_fit = fit_linear_region(X, Y, right_region[0], right_region[1])\nleft_value_at_interface = left_fit[\"slope\"] * interface_x + left_fit[\"intercept\"]\nright_value_at_interface = right_fit[\"slope\"] * interface_x + right_fit[\"intercept\"]\ndelta_v = left_value_at_interface - right_value_at_interface\nleft_electric_field = -left_fit[\"slope\"]\nright_electric_field = -right_fit[\"slope\"]\n\nresult = {\n    \"interface_position\": float(interface_x),\n    \"interface_index\": int(interface_idx),\n    \"delta_v\": float(delta_v),\n    \"left_value_at_interface\": float(left_value_at_interface),\n    \"right_value_at_interface\": float(right_value_at_interface),\n    \"left_fit\": {\n        \"slope\": float(left_fit[\"slope\"]),\n        \"intercept\": float(left_fit[\"intercept\"]),\n        \"r_squared\": float(left_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(left_electric_field),\n    },\n    \"right_fit\": {\n        \"slope\": float(right_fit[\"slope\"]),\n        \"intercept\": float(right_fit[\"intercept\"]),\n        \"r_squared\": float(right_fit[\"r_squared\"]),\n        \"electric_field_eV_per_angstrom\": float(right_electric_field),\n    },\n    \"left_region_indices\": [int(left_region[0]), int(left_region[1])],\n    \"right_region_indices\": [int(right_region[0]), int(right_region[1])],\n}\n\nprint(json.dumps(result, indent=4))\n",
                            "schemaVersion": "2022.8.16"
                        },
                        {
                            "applicationName": "python",
                            "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "contextProviders": [],
                            "executableName": "python",
                            "name": "requirements.txt",
                            "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                            "schemaVersion": "2022.8.16"
                        }
                    ],
                    "next": "0c37a439-d4e4-5376-8c16-1557e99e969b"
                },
                {
                    "name": "Set Polar ESP Fit Result",
                    "type": "assignment",
                    "operand": "ESP_POLAR_FIT_RIGHT",
                    "value": "json.loads(STDOUT)",
                    "input": [
                        {
                            "name": "STDOUT",
                            "scope": "python-fit-esp-polar-right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "0c37a439-d4e4-5376-8c16-1557e99e969b",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        },
        {
            "_id": "58c9c1bb-4893-55ec-a4f3-1072bf25f9fc",
            "name": "Calculate VBO (Polar)",
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "properties": [
                "valence_band_offset",
                "electric_field_left",
                "electric_field_right"
            ],
            "model": {
                "type": "unknown",
                "subtype": "unknown",
                "method": {
                    "type": "unknown",
                    "subtype": "unknown",
                    "data": {}
                }
            },
            "units": [
                {
                    "name": "Difference of valence band maxima",
                    "type": "assignment",
                    "operand": "VBM_DIFF",
                    "value": "VBM_LEFT - VBM_RIGHT",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "bd4eaa98-b001-5694-87ef-ec77540502ab",
                    "tags": [],
                    "head": true,
                    "next": "228c2037-c6ea-57de-b2be-b6d13a3f7f53",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Average ESP reference (left bulk)",
                    "type": "assignment",
                    "operand": "ESP_REF_LEFT",
                    "value": "ESP_POLAR_FIT_LEFT['left_value_at_interface']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "228c2037-c6ea-57de-b2be-b6d13a3f7f53",
                    "tags": [],
                    "head": false,
                    "next": "ef6a6033-6b30-59df-9f65-c186bb53b46d",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Average ESP reference (right bulk)",
                    "type": "assignment",
                    "operand": "ESP_REF_RIGHT",
                    "value": "ESP_POLAR_FIT_RIGHT['right_value_at_interface']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "ef6a6033-6b30-59df-9f65-c186bb53b46d",
                    "tags": [],
                    "head": false,
                    "next": "a7087236-2067-5843-ba4c-75a68cd47397",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Difference of ESP references from bulk calculations",
                    "type": "assignment",
                    "operand": "AVG_ESP_DIFF",
                    "value": "ESP_REF_LEFT - ESP_REF_RIGHT",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "a7087236-2067-5843-ba4c-75a68cd47397",
                    "tags": [],
                    "head": false,
                    "next": "3fa6282e-c4ea-53a6-8d9a-cd9e25fea888",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Delta V from interface linear fit extrapolation",
                    "type": "assignment",
                    "operand": "DELTA_V_INTERFACE",
                    "value": "ESP_POLAR_FIT_INTERFACE['delta_v']",
                    "input": [],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "3fa6282e-c4ea-53a6-8d9a-cd9e25fea888",
                    "tags": [],
                    "head": false,
                    "next": "197f4b4d-cb7b-57be-a885-d44cb1f61905",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Valence Band Offset",
                    "type": "assignment",
                    "operand": "VALENCE_BAND_OFFSET",
                    "value": "abs(VBM_DIFF - AVG_ESP_DIFF + DELTA_V_INTERFACE)",
                    "input": [],
                    "results": [
                        {
                            "name": "valence_band_offset"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "197f4b4d-cb7b-57be-a885-d44cb1f61905",
                    "tags": [],
                    "head": false,
                    "next": "9a87eef8-b096-553f-a180-0b8b7e4ec68e",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Electric field (left side)",
                    "type": "assignment",
                    "operand": "ELECTRIC_FIELD_LEFT",
                    "value": "ESP_POLAR_FIT_INTERFACE['left_fit']['electric_field_eV_per_angstrom']",
                    "input": [],
                    "results": [
                        {
                            "name": "electric_field_left"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "9a87eef8-b096-553f-a180-0b8b7e4ec68e",
                    "tags": [],
                    "head": false,
                    "next": "8d210d18-c0fa-5471-8c9a-bb885620bb3e",
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                },
                {
                    "name": "Electric field (right side)",
                    "type": "assignment",
                    "operand": "ELECTRIC_FIELD_RIGHT",
                    "value": "ESP_POLAR_FIT_INTERFACE['right_fit']['electric_field_eV_per_angstrom']",
                    "input": [],
                    "results": [
                        {
                            "name": "electric_field_right"
                        }
                    ],
                    "status": "idle",
                    "statusTrack": [],
                    "flowchartId": "8d210d18-c0fa-5471-8c9a-bb885620bb3e",
                    "tags": [],
                    "head": false,
                    "application": {
                        "name": "python",
                        "shortName": "py",
                        "summary": "Python Script",
                        "build": "GNU",
                        "isDefault": true,
                        "version": "3.10.13",
                        "schemaVersion": "2022.8.16"
                    }
                }
            ]
        }
    ],
    "units": [
        {
            "name": "BS + Avg ESP (Interface)",
            "type": "subworkflow",
            "_id": "9c65d03e-6a30-58f3-947a-f174342be0c3",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "fd622b5c-5c02-594e-b582-b245c17ca9a4",
            "tags": [],
            "head": true,
            "next": "67770422-0b81-5bbe-b2ba-355a5f920499"
        },
        {
            "name": "Fit Polar ESP (Interface)",
            "type": "subworkflow",
            "_id": "c9192ba7-ce76-5bc7-a156-7029de146550",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "67770422-0b81-5bbe-b2ba-355a5f920499",
            "tags": [],
            "head": false,
            "next": "2eb30f49-5dcb-593c-b389-ac763e7df7aa"
        },
        {
            "name": "BS + Avg ESP (Interface Left)",
            "type": "subworkflow",
            "_id": "438d67a5-7f5f-5e02-93ee-a72cb282af06",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "2eb30f49-5dcb-593c-b389-ac763e7df7aa",
            "tags": [],
            "head": false,
            "next": "f0e75e9e-cc3e-5224-a2e2-81ba4d2ef581"
        },
        {
            "name": "Fit Polar ESP (Interface Left)",
            "type": "subworkflow",
            "_id": "a9699729-298a-5e5f-9f6e-3e7b3b694a6e",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "f0e75e9e-cc3e-5224-a2e2-81ba4d2ef581",
            "tags": [],
            "head": false,
            "next": "a86171a8-2b72-531d-a1cc-0ed3f03797af"
        },
        {
            "name": "BS + Avg ESP (Interface Right)",
            "type": "subworkflow",
            "_id": "06555e5f-08b8-5966-91b6-5ec296bf5fdf",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "a86171a8-2b72-531d-a1cc-0ed3f03797af",
            "tags": [],
            "head": false,
            "next": "bf6caeb4-db41-58c5-995c-3874b728eaa6"
        },
        {
            "name": "Fit Polar ESP (Interface Right)",
            "type": "subworkflow",
            "_id": "0b8d0aca-ccd7-55c7-8bf9-2970792cee12",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "bf6caeb4-db41-58c5-995c-3874b728eaa6",
            "tags": [],
            "head": false,
            "next": "1c718041-09aa-5a6e-a57f-5d0b221edc37"
        },
        {
            "name": "Calculate VBO (Polar)",
            "type": "subworkflow",
            "_id": "58c9c1bb-4893-55ec-a4f3-1072bf25f9fc",
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "1c718041-09aa-5a6e-a57f-5d0b221edc37",
            "tags": [],
            "head": false
        }
    ],
    "properties": [
        "atomic_forces",
        "average_potential_profile",
        "band_gaps",
        "fermi_energy",
        "pressure",
        "stress_tensor",
        "total_energy",
        "total_energy_contributions",
        "total_force"
    ],
    "_id": "d8e08cac-7747-50aa-b925-41f214d722c6",
    "workflows": [],
    "schemaVersion": "2022.8.16",
    "isDefault": false,
    "application": {
        "name": "espresso"
    }
}
