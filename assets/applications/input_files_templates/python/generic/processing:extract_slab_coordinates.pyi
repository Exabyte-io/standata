#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Extract z-coordinate boundaries from materials for polar VBO calculation.

Reads structure from pw_scf.out file using ASE and extracts z-coordinates.
"""
import json
import os

import numpy as np
import ase.io
from mat3ra.made.material import Material
from mat3ra.made.tools.convert import from_ase

# Material index: 0=Interface, 1=Left, 2=Right
{% raw %}material_index = int({{material_index}}){% endraw %}

# Read structure from pw_scf.out (generated by previous pw_scf calculation)
# Files are named: pw_scf.out (index 0), pw_scf.out-1 (index 1), pw_scf.out-2 (index 2)
if material_index == 0:
    pw_scf_output = "./pw_scf.out"
else:
    pw_scf_output = f"./pw_scf.out-{material_index}"

if not os.path.exists(pw_scf_output):
    raise FileNotFoundError(f"Required file '{pw_scf_output}' not found. Cannot extract slab coordinates.")

# Read atomic structure from espresso output
atoms = ase.io.read(pw_scf_output, format="espresso-out")

# Convert ASE Atoms to Material using mat3ra-made
material = Material.create(from_ase(atoms))

# Extract z-coordinates
coordinates = material.basis.coordinates
z_coords_frac = np.array(coordinates.get_values_along_axis(axis="z"))

# Convert to Cartesian (Angstroms)
c_length = material.lattice.c
z_coords_angstrom = z_coords_frac * c_length

# Extract z-range for this material
z_min = np.min(z_coords_angstrom)
z_max = np.max(z_coords_angstrom)

# Return just this material's coordinates
# The workflow will map them to slab1 (for Left) or slab2 (for Right)
result = {
    "z_min": float(z_min),
    "z_max": float(z_max),
    "material_index": material_index,
}

print(json.dumps(result, indent=4))
