{
    "_id": "56253784-b62a-513a-8ed3-3a12d6d1c152",
    "name": "Fit Polar ESP",
    "application": {
        "name": "espresso"
    },
    "properties": [],
    "model": {
        "type": "unknown",
        "subtype": "unknown",
        "method": {
            "type": "unknown",
            "subtype": "unknown",
            "data": {}
        }
    },
    "units": [
        {
            "type": "execution",
            "name": "Fit Linear ESP for Polar Interface",
            "head": true,
            "results": [],
            "monitors": [
                {
                    "name": "standard_output"
                }
            ],
            "flowchartId": "python-fit-esp-polar",
            "preProcessors": [],
            "postProcessors": [],
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            },
            "executable": {
                "isDefault": true,
                "monitors": [
                    "standard_output"
                ],
                "name": "python",
                "schemaVersion": "2022.8.16"
            },
            "flavor": {
                "applicationName": "python",
                "executableName": "python",
                "input": [
                    {
                        "name": "fit_esp_polar.py",
                        "templateName": "fit_esp_polar.py"
                    },
                    {
                        "name": "requirements.txt",
                        "templateName": "processing_requirements.txt"
                    }
                ],
                "monitors": [
                    "standard_output"
                ],
                "name": "espresso:processing:fit_esp_polar",
                "schemaVersion": "2022.8.16",
                "isDefault": false
            },
            "status": "idle",
            "statusTrack": [],
            "tags": [],
            "input": [
                {
                    "applicationName": "python",
                    "content": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\n{% raw %}profile = {{average_potential_profile}}{% endraw %}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V̄(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\n{% raw %}SLAB1_MIN = float({{slab1_min}}){% endraw %}\n{% raw %}SLAB1_MAX = float({{slab1_max}}){% endraw %}\n{% raw %}SLAB2_MIN = float({{slab2_min}}){% endraw %}\n{% raw %}SLAB2_MAX = float({{slab2_max}}){% endraw %}\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        return float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa = fit_and_average(X, Y, slab1_start, slab1_end)\nVb = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n",
                    "contextProviders": [],
                    "executableName": "python",
                    "name": "fit_esp_polar.py",
                    "rendered": "# ------------------------------------------------------------------ #\n# Linear Fit of ESP for Polar Interface VBO Calculation              #\n# ------------------------------------------------------------------ #\n# Reference: Choudhary & Garrity, arXiv:2401.02021 (InterMat)        #\n#                                                                    #\n# For polar interfaces, ESP shows linear gradient in bulk regions    #\n# due to internal electric field. We fit each slab region and use    #\n# the average value of the fit as the bulk ESP reference.            #\n#                                                                    #\n# Input: Coordinates defining slab regions (from structure data)     #\n#   - slab1_min, slab1_max: z-coordinates of first material region   #\n#   - slab2_min, slab2_max: z-coordinates of second material region  #\n#                                                                    #\n# Output: Va, Vb - average ESP values for each slab region           #\n# ------------------------------------------------------------------ #\nimport json\n\nimport numpy as np\nfrom munch import Munch\nfrom scipy.stats import linregress\n\n# Data from context: macroscopic average potential profile\nprofile = {{average_potential_profile}}\n\nX = np.array(profile.xDataArray)  # z-coordinates (angstrom)\nY = np.array(profile.yDataSeries[1])  # Macroscopic average V̄(z)\n\n# Slab region coordinates (passed from workflow, set by user based on structure)\n# These define z-coordinate ranges for fitting in each material region\nSLAB1_MIN = float({{slab1_min}})\nSLAB1_MAX = float({{slab1_max}})\nSLAB2_MIN = float({{slab2_min}})\nSLAB2_MAX = float({{slab2_max}})\n\n\ndef get_region_indices(x_data, x_min, x_max):\n    \"\"\"Get array indices corresponding to coordinate range.\"\"\"\n    mask = (x_data >= x_min) & (x_data <= x_max)\n    indices = np.where(mask)[0]\n    if len(indices) == 0:\n        return 0, len(x_data)\n    return indices[0], indices[-1] + 1\n\n\ndef fit_and_average(x_data, y_data, start_idx, end_idx):\n    \"\"\"\n    Fit linear regression to region and return average value.\n    \n    The average of the fitted line equals the mean of y-values,\n    but fitting helps smooth out oscillations and validates linearity.\n    \"\"\"\n    x_region = x_data[start_idx:end_idx]\n    y_region = y_data[start_idx:end_idx]\n    \n    if len(x_region) < 2:\n        return float(np.mean(y_region)) if len(y_region) > 0 else 0.0\n    \n    slope, intercept, r_value, _, _ = linregress(x_region, y_region)\n    \n    # Average value of linear fit over the region\n    # V_avg = (1/L) * integral(slope*x + intercept) = slope*x_mid + intercept\n    x_mid = (x_region[0] + x_region[-1]) / 2.0\n    avg_value = slope * x_mid + intercept\n    \n    return float(avg_value)\n\n\n# Get indices for each slab region\nslab1_start, slab1_end = get_region_indices(X, SLAB1_MIN, SLAB1_MAX)\nslab2_start, slab2_end = get_region_indices(X, SLAB2_MIN, SLAB2_MAX)\n\n# Fit and get average ESP for each slab\nVa = fit_and_average(X, Y, slab1_start, slab1_end)\nVb = fit_and_average(X, Y, slab2_start, slab2_end)\n\n# Output compatible with VBO workflow (same format as find_extrema.pyi)\nresult = {\n    \"minima\": [Va, Vb],\n    \"maxima\": [],\n}\n\nprint(json.dumps(result, indent=4))\n",
                    "schemaVersion": "2022.8.16"
                },
                {
                    "applicationName": "python",
                    "content": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                    "contextProviders": [],
                    "executableName": "python",
                    "name": "requirements.txt",
                    "rendered": "# ----------------------------------------------------------------- #\n#                                                                   #\n#  Example Python package requirements for the Mat3ra platform      #\n#                                                                   #\n#  Will be used as follows:                                         #\n#                                                                   #\n#    1. A runtime directory for this calculation is created         #\n#    2. This list is used to populate a Python virtual environment  #\n#    3. The virtual environment is activated                        #\n#    4. The Python process running the script included within this  #\n#       job is started                                              #\n#                                                                   #\n#  For more information visit:                                      #\n#   - https://pip.pypa.io/en/stable/reference/pip_install           #\n#   - https://virtualenv.pypa.io/en/stable/                         #\n#                                                                   #\n# ----------------------------------------------------------------- #\n\n\nmunch==2.5.0\nnumpy>=1.19.5\nscipy>=1.5.4\nmatplotlib>=3.0.0\n",
                    "schemaVersion": "2022.8.16"
                }
            ],
            "next": "8fce780b-5555-5b73-b3d1-1bb24a4c759d"
        },
        {
            "name": "Set Average ESP Value",
            "type": "assignment",
            "operand": "AVG_ESP",
            "value": "json.loads(STDOUT)['minima']",
            "input": [
                {
                    "name": "STDOUT",
                    "scope": "python-fit-esp-polar"
                }
            ],
            "status": "idle",
            "statusTrack": [],
            "flowchartId": "8fce780b-5555-5b73-b3d1-1bb24a4c759d",
            "tags": [],
            "head": false,
            "application": {
                "name": "python",
                "shortName": "py",
                "summary": "Python Script",
                "build": "GNU",
                "isDefault": true,
                "version": "3.10.13",
                "schemaVersion": "2022.8.16"
            }
        }
    ]
}
